}
train_dl <- dataloader(tensor_dataset(ds$x, ds$y), batch_size=batch_size, shuffle=TRUE)
model <- LSTMModel()$to(device=device)
optimizer <- optim_adam(model$parameters, lr=lr)
loss_fn <- nn_mse_loss()
model$train()
for(epoch in seq_len(epochs)){
coro::loop(for(b in train_dl){
optimizer$zero_grad()
loss <- loss_fn(model(b[[1]])$squeeze(), b[[2]])
loss$backward()
optimizer$step()
})
}
model$eval()
with_no_grad({
preds <- model(ds$x)$cpu()$squeeze()
})
preds <- as.numeric(preds)
return(list(preds = preds, min = min_val, max = max_val))
}
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf2_raw <- train_lstm_component(res_sep$f2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pd2_raw <- train_lstm_component(res_sep$d2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
cat("Range pf0 (scaled):", range(pf0_raw$preds, na.rm = TRUE), "\n")
cat("Range pf1 (scaled):", range(pf1_raw$preds, na.rm = TRUE), "\n")
cat("Range pf2 (scaled):", range(pf2_raw$preds, na.rm = TRUE), "\n")
cat("Range pd2 (scaled):", range(pd2_raw$preds, na.rm = TRUE), "\n")
print(summary(pf0_raw$preds))
print(summary(pf1_raw$preds))
print(summary(pf2_raw$preds))
print(summary(pf2_raw$preds))
# Inverse từng phần
pf0 <- minmax_inverse(pf0_raw$preds, pf0_raw$min, pf0_raw$max)
pf1 <- minmax_inverse(pf1_raw$preds, pf1_raw$min, pf1_raw$max)
pf2 <- minmax_inverse(pf2_raw$preds, pf2_raw$min, pf2_raw$max)
pd2 <- minmax_inverse(pd2_raw$preds, pd2_raw$min, pd2_raw$max)
# Tổng hợp dự báo
r_hat <- pf0 + pf1 + pf2 + pd2
true <- tail(res_sep$R, length(r_hat))
# Đánh giá
result <- list(
params = param_grid[1, ],
MAE  = mean(abs(true - r_hat), na.rm = TRUE),
RMSE = sqrt(mean((true - r_hat)^2, na.rm = TRUE)),
MAPE = mean(abs((true - r_hat) / true), na.rm = TRUE) * 100,
R2   = r_squared(true, r_hat)
)
print(result)
View(minmax_scale)
View(minmax_scale)
rm(dlwr_separation)
dlwr_separation <- function(data, date_col, value_col, params){
data <- data[order(data[[date_col]]), ]
x <- seq_len(nrow(data))
R <- data[[value_col]]
# Vòng 1: start_t = 1
f0 <- dlwr_fit_vectorized(x, R, params$n, params$deg, params$alpha, start_t=1)
d0 <- R - f0
# Vòng 2: start_t = 2*n - 1
f1 <- dlwr_fit_vectorized(x, d0, params$n, params$deg, params$alpha, start_t=2*params$n - 1)
d1 <- d0 - f1
# Vòng 3: start_t = 3*n - 2
f2 <- dlwr_fit_vectorized(x, d1, params$n, params$deg, params$alpha, start_t=3*params$n - 2)
d2 <- d1 - f2
cut_idx <- 3 * params$n - 3
result_df <- data.frame(date=data[[date_col]], R, f0, f1, f2, d2)
result_df <- result_df[-seq_len(cut_idx), ]
return(na.omit(result_df))
}
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf2_raw <- train_lstm_component(res_sep$f2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pd2_raw <- train_lstm_component(res_sep$d2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
cat("Range pf0 (scaled):", range(pf0_raw$preds, na.rm = TRUE), "\n")
cat("Range pf1 (scaled):", range(pf1_raw$preds, na.rm = TRUE), "\n")
cat("Range pf2 (scaled):", range(pf2_raw$preds, na.rm = TRUE), "\n")
cat("Range pd2 (scaled):", range(pd2_raw$preds, na.rm = TRUE), "\n")
print(summary(pf0_raw$preds))
print(summary(pf1_raw$preds))
print(summary(pf2_raw$preds))
print(summary(pf2_raw$preds))
# Inverse từng phần
pf0 <- minmax_inverse(pf0_raw$preds, pf0_raw$min, pf0_raw$max)
pf1 <- minmax_inverse(pf1_raw$preds, pf1_raw$min, pf1_raw$max)
pf2 <- minmax_inverse(pf2_raw$preds, pf2_raw$min, pf2_raw$max)
pd2 <- minmax_inverse(pd2_raw$preds, pd2_raw$min, pd2_raw$max)
# Tổng hợp dự báo
r_hat <- pf0 + pf1 + pf2 + pd2
true <- tail(res_sep$R, length(r_hat))
# Đánh giá
result <- list(
params = param_grid[1, ],
MAE  = mean(abs(true - r_hat), na.rm = TRUE),
RMSE = sqrt(mean((true - r_hat)^2, na.rm = TRUE)),
MAPE = mean(abs((true - r_hat) / true), na.rm = TRUE) * 100,
R2   = r_squared(true, r_hat)
)
print(result)
rm(train_lstm_component)
train_lstm_component <- function(series, lookback, epochs, batch_size, lr, device){
print(paste("Check inputs: lookback =", lstm_p$lookback,
"epochs =", lstm_p$epochs,
"batch_size =", lstm_p$batch_size,
"lr =", lstm_p$lr))
print(paste("độ dài chuỗi:", length(series)))
# Bắt buộc chuyển về numeric và xử lý triệt để
series <- as.numeric(series)
series <- series[is.finite(series)]
# Kiểm tra độ dài chuỗi phải lớn hơn lookback
if(length(series) <= lookback){
warning("Chuỗi không đủ dữ liệu sau khi làm sạch.")
return(rep(NA, length(series)))
}
# Bước 2: MinMax normalization
scaled <- minmax_scale(series)
scaled_series <- scaled$scaled
min_val <- scaled$min
max_val <- scaled$max
ds <- create_dataset(scaled_series, lookback)
if(length(ds$y) < batch_size){
warning("Không đủ dữ liệu để huấn luyện mô hình với batch_size hiện tại.")
return(rep(NA, length(series)))
}
train_dl <- dataloader(tensor_dataset(ds$x, ds$y), batch_size=batch_size, shuffle=TRUE)
model <- LSTMModel()$to(device=device)
optimizer <- optim_adam(model$parameters, lr = lr)
loss_fn <- nn_mse_loss()
model$train()
for(epoch in seq_len(epochs)){
coro::loop(for(b in train_dl){
optimizer$zero_grad()
loss <- loss_fn(model(b[[1]])$squeeze(), b[[2]])
loss$backward()
optimizer$step()
})
}
model$eval()
with_no_grad({
preds <- model(ds$x)$cpu()$squeeze()
})
preds <- as.numeric(preds)
return(list(preds = preds, min = min_val, max = max_val))
}
rm(train_lstm_component)
train_lstm_component <- function(series, lookback, epochs, batch_size, lr, device){
print(paste("Check inputs: lookback =", lstm_p$lookback,
"epochs =", lstm_p$epochs,
"batch_size =", lstm_p$batch_size,
"lr =", lstm_p$lr))
print(paste("độ dài chuỗi:", length(series)))
# Bắt buộc chuyển về numeric và xử lý triệt để
series <- as.numeric(series)
series <- series[is.finite(series)]
# Kiểm tra độ dài chuỗi phải lớn hơn lookback
if(length(series) <= lookback){
warning("Chuỗi không đủ dữ liệu sau khi làm sạch.")
return(rep(NA, length(series)))
}
# Bước 2: MinMax normalization
scaled <- minmax_scale(series)
scaled_series <- scaled$scaled
min_val <- scaled$min
max_val <- scaled$max
ds <- create_dataset(scaled_series, lookback)
if(length(ds$y) < batch_size){
warning("Không đủ dữ liệu để huấn luyện mô hình với batch_size hiện tại.")
return(rep(NA, length(series)))
}
train_dl <- dataloader(tensor_dataset(ds$x, ds$y), batch_size=batch_size, shuffle=TRUE)
model <- LSTMModel()$to(device=device)
optimizer <- optim_adam(model$parameters, lr = lr)
loss_fn <- nn_mse_loss()
model$train()
for(epoch in seq_len(epochs)){
coro::loop(for(b in train_dl){
optimizer$zero_grad()
loss <- loss_fn(model(b[[1]])$squeeze(), b[[2]])
loss$backward()
optimizer$step()
})
}
model$eval()
with_no_grad({
preds <- model(ds$x)$cpu()$squeeze()
})
preds <- as.numeric(preds)
summary(preds)
return(list(preds = preds, min = min_val, max = max_val))
}
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
create_dataset <- function(series, lookback){
series_tensor <- torch_tensor(series, dtype = torch_float())
series_tensor <- series_tensor$to(device = device)
X <- lapply(1:(length(series_tensor)-lookback), function(i) series_tensor[i:(i+lookback-1)]$unsqueeze(2))
Y <- series_tensor[(lookback+1):length(series_tensor)]
list(x = torch_stack(X), y = Y)
}
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf2_raw <- train_lstm_component(res_sep$f2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pd2_raw <- train_lstm_component(res_sep$d2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
cat("Range pf0 (scaled):", range(pf0_raw$preds, na.rm = TRUE), "\n")
cat("Range pf1 (scaled):", range(pf1_raw$preds, na.rm = TRUE), "\n")
cat("Range pf2 (scaled):", range(pf2_raw$preds, na.rm = TRUE), "\n")
cat("Range pd2 (scaled):", range(pd2_raw$preds, na.rm = TRUE), "\n")
print(summary(pf0_raw$preds))
print(summary(pf1_raw$preds))
print(summary(pf2_raw$preds))
print(summary(pf2_raw$preds))
# Inverse từng phần
pf0 <- minmax_inverse(pf0_raw$preds, pf0_raw$min, pf0_raw$max)
pf1 <- minmax_inverse(pf1_raw$preds, pf1_raw$min, pf1_raw$max)
pf2 <- minmax_inverse(pf2_raw$preds, pf2_raw$min, pf2_raw$max)
pd2 <- minmax_inverse(pd2_raw$preds, pd2_raw$min, pd2_raw$max)
# Tổng hợp dự báo
r_hat <- pf0 + pf1 + pf2 + pd2
true <- tail(res_sep$R, length(r_hat))
# Đánh giá
result <- list(
params = param_grid[1, ],
MAE  = mean(abs(true - r_hat), na.rm = TRUE),
RMSE = sqrt(mean((true - r_hat)^2, na.rm = TRUE)),
MAPE = mean(abs((true - r_hat) / true), na.rm = TRUE) * 100,
R2   = r_squared(true, r_hat)
)
print(result)
summary(pf0_raw)
summary(pf0_raw$preds)
summary(pf1_raw$preds)
summary(pf2_raw$preds)
summary(pd2_raw$preds)
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
###############
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
summary(res_sep$f1)
summary(res_sep$d2)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf2_raw <- train_lstm_component(res_sep$f2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pd2_raw <- train_lstm_component(res_sep$d2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
cat("Range pf0 (scaled):", range(pf0_raw$preds, na.rm = TRUE), "\n")
cat("Range pf1 (scaled):", range(pf1_raw$preds, na.rm = TRUE), "\n")
cat("Range pf2 (scaled):", range(pf2_raw$preds, na.rm = TRUE), "\n")
cat("Range pd2 (scaled):", range(pd2_raw$preds, na.rm = TRUE), "\n")
print(summary(pf0_raw$preds))
print(summary(pf1_raw$preds))
print(summary(pf2_raw$preds))
print(summary(pf2_raw$preds))
# Inverse từng phần
pf0 <- minmax_inverse(pf0_raw$preds, pf0_raw$min, pf0_raw$max)
pf1 <- minmax_inverse(pf1_raw$preds, pf1_raw$min, pf1_raw$max)
pf2 <- minmax_inverse(pf2_raw$preds, pf2_raw$min, pf2_raw$max)
pd2 <- minmax_inverse(pd2_raw$preds, pd2_raw$min, pd2_raw$max)
# Tổng hợp dự báo
r_hat <- pf0 + pf1 + pf2 + pd2
true <- tail(res_sep$R, length(r_hat))
# Đánh giá
result <- list(
params = param_grid[1, ],
MAE  = mean(abs(true - r_hat), na.rm = TRUE),
RMSE = sqrt(mean((true - r_hat)^2, na.rm = TRUE)),
MAPE = mean(abs((true - r_hat) / true), na.rm = TRUE) * 100,
R2   = r_squared(true, r_hat)
)
print(result)
###############
param_grid <- data.frame(
n = 15,
deg = 1,
alpha = 0.2,
lookback = 10,
epochs = 20,
batch_size = 16,
lr = 0.001
)
# Lấy tham số ra
dlwr_p <- list(
n     = param_grid$n[1],
deg   = param_grid$deg[1],
alpha = param_grid$alpha[1]
)
lstm_p <- list(
lookback    = param_grid$lookback[1],
epochs      = param_grid$epochs[1],
batch_size  = param_grid$batch_size[1],
lr          = param_grid$lr[1]
)
# Tạo tập DLWR
res_sep <- dlwr_separation(data, "date", "vnindex_close", dlwr_p)
cat("Range f0:", range(res_sep$f0, na.rm = TRUE), "\n")
cat("Range f1:", range(res_sep$f1, na.rm = TRUE), "\n")
cat("Range f2:", range(res_sep$f2, na.rm = TRUE), "\n")
cat("Range d2:", range(res_sep$d2, na.rm = TRUE), "\n")
device <- torch_device(if (cuda_is_available()) "cuda" else "cpu")
summary(res_sep)
# Dự báo từng thành phần (trả về list chứa preds, min, max)
summary(res_sep$f1)
summary(res_sep$d2)
pf0_raw <- train_lstm_component(res_sep$f0, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf1_raw <- train_lstm_component(res_sep$f1, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pf2_raw <- train_lstm_component(res_sep$f2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
pd2_raw <- train_lstm_component(res_sep$d2, lstm_p$lookback, lstm_p$epochs, lstm_p$batch_size, lstm_p$lr, device)
cat("Range pf0 (scaled):", range(pf0_raw$preds, na.rm = TRUE), "\n")
cat("Range pf1 (scaled):", range(pf1_raw$preds, na.rm = TRUE), "\n")
cat("Range pf2 (scaled):", range(pf2_raw$preds, na.rm = TRUE), "\n")
cat("Range pd2 (scaled):", range(pd2_raw$preds, na.rm = TRUE), "\n")
print(summary(pf0_raw$preds))
print(summary(pf1_raw$preds))
print(summary(pf2_raw$preds))
print(summary(pf2_raw$preds))
# Inverse từng phần
pf0 <- minmax_inverse(pf0_raw$preds, pf0_raw$min, pf0_raw$max)
pf1 <- minmax_inverse(pf1_raw$preds, pf1_raw$min, pf1_raw$max)
pf2 <- minmax_inverse(pf2_raw$preds, pf2_raw$min, pf2_raw$max)
pd2 <- minmax_inverse(pd2_raw$preds, pd2_raw$min, pd2_raw$max)
# Tổng hợp dự báo
r_hat <- pf0 + pf1 + pf2 + pd2
true <- tail(res_sep$R, length(r_hat))
# Đánh giá
result <- list(
params = param_grid[1, ],
MAE  = mean(abs(true - r_hat), na.rm = TRUE),
RMSE = sqrt(mean((true - r_hat)^2, na.rm = TRUE)),
MAPE = mean(abs((true - r_hat) / true), na.rm = TRUE) * 100,
R2   = r_squared(true, r_hat)
)
print(result)
plot(true, type = "l", col = "blue", lwd = 2, ylim = range(c(true, r_hat)), ylab = "Value", xlab = "Index", main = "True vs Predicted (r_hat)")
lines(r_hat, col = "red", lwd = 2, lty = 2)
legend("topleft", legend = c("True", "Predicted (r_hat)"), col = c("blue", "red"), lty = c(1, 2), lwd = 2)
